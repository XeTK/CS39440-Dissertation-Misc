\chapter{Implementation}This chapter covers in details the implementation of the features covered within the design chapter and will list in detail the general implementation of a feature including there issues, it will also detail the environments and tools used to create the application and the supporting services behind the application.\section{Tools used}In this section the tools used for building the application and backend services will be detailed and there role within the development of the project as a whole.\subsection*{Sublime Text}Sublime Text is one of the main tools that was used throughout the development of the project, it is highly regarded as one of the best text editors in the public space due to its flexibility and community support to help it fit the users needs.\\\\It has been a crucial tool for developing the middle tier application as all of the code was written in sublime text, this report that you are reading now was exclusively written in Sublime Text and the vast majority of the SQL was also writing within the Sublime Text editor. In image of the text editor can be found in figure \ref{fig:sublime_text_image}.\begin{figure}[H]    \centering    \includegraphics[width=\textwidth]{tools/sublime}    \caption{Sublime Text 3.0}    \label{fig:sublime_text_image}\end{figure} \subsection*{Android Studio}Android Studio has played the most crucial role within the development of the project it has been the integrated development environment of choice for Android development giving all the required features and tools needed to create a fully fledged Android application with the potential of being released into a production environment, it contains all of the testing tools required to do good Android development with a unit testing suite and various UI testing suites.\\\\It has close links to the Android SDK so it enables users to use the various Android SDK tools within the Android Studio GUI some of the advanced tools within the Android SDK are covered later in this section. Android Studio offers powerful code completion tools and refactoring tools to speed up the development of the application it also has the ability to error check the code and provide solutions through the development of the project with powerful auto complete tools to build up the stub functions to complete the implementation of imported libraries. An example of the layout and design of Android studio can be found in figure \ref{fig:android_studio_image}.\begin{figure}[H]    \centering    \includegraphics[width=\textwidth]{tools/androidstudio}    \caption{Android Studio 1.1.0}    \label{fig:android_studio_image}\end{figure} \subsection*{PGAdmin3}PGAdmin3 is a tool for remotely accessing Postgres database and allowing management through a GUI based interface, it allows easy access to viewing data held within the database along with the ability to execute SQL commands directly on the database. The tool was mostly used as a verifier to check that SQL executed within the terminal had run correctly and had created the tables and constraints that were needed for the application to work correctly. Small note this crashes a lot on a Apple Mac, An example of the execution of PGAdmin3 can be found in figure \ref{fig:pg_admin_image}.\begin{figure}[H]    \centering    \includegraphics[width=\textwidth]{tools/pgadmin}    \caption{PGAdmin3 1.20.0}    \label{fig:pg_admin_image}\end{figure} \subsection*{PGSQL command line}The PostgreSQL command line tool was used in conjunction with PGAdmin3 to do all the SQL related work needed for the project, the PostgeSQL command line allows direct command execution within the SQL engine so is perfect for debugging issues within the database along with creating the SQL statements to extract the data needed to get the functional requirements of the application working correctly.\\\\PostgreSQL its self is fairly difficult to install correctly and there were many issues with getting it to install correctly and work as intended, the command line package manager for Apple Mac Homebrew PostgeSQL's package is completely broken and caused massive headaches at the start of the project theses issues were resolved by installing the official DMG package provided by Postgres.app \cite{jemt:postgresapp:2015:online}.\begin{figure}[H]    \centering    \includegraphics[width=\textwidth]{tools/pgsqlcommandline}    \caption{PG SQL Command line 9.3.6}    \label{fig:pg_sql_image}\end{figure} \subsection*{Postman}Postman was an essential tool for debugging the RESTful interfaces provided by the applications, it enables the emulation of HTTP POST and GET requests enabling the ability to attach the parameters needed when completing a POST request and making sure the interface is working correctly without the need to implementing it fully into the application. It was often used to check if the RESTful interface was working correctly before implementing the corresponding code within the Android side of the application, Postman its self has a few issues, if a request would fail for what ever reason the application would get stuck in the sending request stage and would require closing the tab and re opening. An image of Postman at work can be found in figure \ref{fig:postman_image}.\begin{figure}[H]    \centering    \includegraphics[width=\textwidth]{tools/postman}    \caption{Postman 2.0.19}    \label{fig:postman_image}\end{figure} \subsection*{Web browsers}A web browser is an essential tool in any software related tool in the modern world, It was primary used for researching the project as a whole but it was also used for debugging the backend API as it can carry out HTTP requests, accept cookies and deal with HTTP authentication. They were often used to complement Postman when it could not quite carry out the required action that was needed.\\\\The two main browsers used to test the application were Opera And Google Chrome, Opera being my main browser so Chrome was used as a backup when needed. Images of the two main browsers that were used can be found in figures \ref{fig:opera_image} and \ref{fig:chrome_image}.\begin{figure}[H]    \centering    \includegraphics[width=\textwidth]{tools/opera}    \caption{Opera 28.0}    \label{fig:opera_image}\end{figure} \begin{figure}[H]    \centering    \includegraphics[width=\textwidth]{tools/chrome}    \caption{Chrome 43.0}    \label{fig:chrome_image}\end{figure} \subsection*{Android SDK Tools}Throughout the development of the project there was a need to use the full Android Software Development Kit for testing and debugging the application in the given environment it will be run. The SDK provides all of the build tools needed to create and compile the packages needed to install the application on the device along with submit it to the Google Play Store.\\\\The first and possible most used tool throughout the development of the application is the Android Emulator, the tool emulates the Android platform on the development machine to provide an environment to test code without the need of a physical device this can be useful when the developer only has a limited selection of devices to test the application on as the emulator gives the ability to scale to different screen sizes and resolutions to help with debugging on different devices. In figure \ref{fig:android_emulator} shows the emulator at work running the application in a test mode.\begin{figure}[H]    \centering    \includegraphics[width=0.5\textwidth]{tools/androidemulator}    \caption{Android Emulator SDK 22}    \label{fig:android_emulator}\end{figure} \label{sec:adb}\noindentAnother equally important tool that was used extensively during the development of the project was the command line application Android Development Bridge(ADB). ADB is used to interface with Android based devices and provides many features that allow interfacing and connecting to the device, it is crucial for debugging applications along with working with the Operating System directly. It has been extensively used through this project to repair damaged and broken phones to bring them back to a state where they can be used to help with development.\begin{figure}[H]    \centering    \includegraphics[width=0.75\textwidth]{tools/adb}    \caption{Android Development Bridge}    \label{fig:adb_image}\end{figure} \noindentThe SDK updater played a very minor in the project but it allows easy and quick way to update the SDK and build tools within the Android development suite to the latest versions to enable development for newer devices as they come to market.\begin{figure}[H]    \centering    \includegraphics[width=0.75\textwidth]{tools/sdkupdator}    \caption{Android SDK Updater}    \label{fig:sdk_updator}\end{figure} \subsection*{Git Hub}Throughout the project the version control system GIT has been used to ensure that the source code for the project has been reliably backed up and provide the ability to check in versions of the code to return to a prior point if needed.\\\\The use of the service GitHub as a on-line repository to keep the code easily accessible and backed up throughout the project along using some of the extra functionality by using a 3rd party to store and look after the source code. In future it will enable people to contribute to the project and do there own tweaks and improvements to ensure that the project becomes a fully fledged and vibrant application. The standard GitHub page layout can be found in figure \ref{fig:git_hub_repos_image}.\begin{figure}[H]    \centering    \includegraphics[width=\textwidth]{tools/github}    \caption{Git Hub git repositories}    \label{fig:git_hub_repos_image}\end{figure} \noindentGitHub provides a issue tracker so that users can leave issues and bug reports for the developer to fix or improve, it has been integral throughout the project to keep track of any issues that have been raised within the development of the application.\\\\They have been marked as fixed or left ready to be fixed in the future development of the application and gives a traceable history of any issues within the application. The UI for the issue tracker can be found in figure \ref{fig:gh_issue_tracker_image}.\begin{figure}[H]    \centering    \includegraphics[width=\textwidth]{tools/githubissues}    \caption{Github issue tracker}    \label{fig:gh_issue_tracker_image}\end{figure} \section{Android application}This section will cover the various elements required to develop the Android Application and how the overall implementation came together.\subsection{Development Hardware}\label{sec:dev_hardware}The development hardware used from the project consisted of multiple phones to test application the primary device was a HTC One M7 running for the majority of the project Android 5.0.2, secondary to that device there was a large chunk of development completed on a LG Nexus 4 kindly donated by Alexander Stuart which ran Android 5.1, further hardware consistently used were two Samsung Galaxy S2's one a i9100 and the other a i9100p theses devices were very cheap to ascertain and were very good for testing various versions of Android as they could easily be modified to suite the needs the primary S2 that was used ran Android 4.1.2 and was completely standard, the second ran a version of CyanogenMod 11 which equated to Android 4.4.4.\\\\Most of the issues ran into during the development were caused by the development hardware used, as most of theses devices were second hard or lend on request that they were repaired this caused a multitude of issues. At the start of the project the only device that was available was the HTC One M7 as this is my personal device when starting the project the device ran a custom version of Android 4.4.4 which had a issue with allowing access to ADB(details of ADB can be found in section \ref{sec:adb}) which meant that deploying the application onto the device was impossible, after much toil and trying different roms and versions of Android it was possible to get the device into a state where ADB would work but the device as a whole was not stable thus useless for development. At this point the HTC was reverted to is prior state and the first Samsung Galaxy S2 was acquired but this did not come without its own issues as it had Android 4.0.2 and a intermittent fault with the back button meaning it was useless after some research it was clear that the issue was a software problem but tracing a standard rom for the phone proved very difficult but once one was acquired and the use of a Mirosoft Windows machine to flash the phone this S2 became the test mule for the application until HTC released the 5.0.2 update for the HTC One M7 which meant the HTC became the primary phone for development.\\\\The two other phones used the LG Nexus 4 and second Samsung Galaxy S2 came with hardware faults before they could be used in the development of the application, the LG Nexus 4 had a faulty USB port so until the port was replaced charging and the use ADB was not possible as it requires USB to work. For the Samsung Galaxy S2 more work was needed as the motherboard was heavily corroded due to exposure to water luckily there was a spare Galaxy S2 with a faulty screen in a box of my spares so swapping the board created one working phone.\\\\After theses issues development was straight forward, theses issues happened within the first few weeks of the project in the configuration and setup stages but it did eat up considerable time that could have been dedicated to development and caused many hours of frustration, it was a reminder that hardware is unpredictable and stability is not guaranteed.\\\\One problem that was not foreseen before the development of project and varied heavily between devices was the ability for the device to pickup reliable GPS signals, the Samsung Galaxy S2's used had considerable problems getting a valid GPS fix the HTC One \& LG Nexus did a much better job of this but a lot of the time it proved very difficult to get a stable and reliable GPS fix thus for large proportion of the development spoofing the location to the device was the only way to test the application.\subsection{Environment}The Android development environment was a large source of frustration during the development of the project as it was very difficult for get the Software Development Kit configured correctly it would often have issues with the PATH variable within command line interface which would mean ADB would become unaccessible meaning deploying and debugging the application was impossible, this would sometimes require a complete reinstall of the SDK to resolve the issue with large amount of time reconfiguring to get back to a workable state.\\\\There were also many issues with the Android Emulator which made it either not load or just crash unexpectedly at any point usually at a critical time within testing, due to this it was preferred to use a physical device when possible as they were much more stable and less likely to flake out during the deployment of the application but as discussed in section \ref{sec:dev_hardware} this could also be very problematic.\\\\One theses issues were known it was fairly easy to work around them and with a bit of patiences could be resolved fairly quickly if and when they cropped up, when everything was working correctly Android was a fairly nice platform to work with alot of robust and useful utilities for deploying and building the application, the SDK and Android Studio include all the tools to develop, compile, sign and submit full fledged applications to the Google Play store.\subsection{Features}This section will cover the implementation of all of the major features within the application, the subsections correspond to the functional requirements set out in chapter \ref{ch:design} section \ref{sec:functionality}.\subsubsection*{Login}\paragraph*{Implementation}\paragraph*{Issues}\subsubsection*{Registration}\paragraph*{Implementation}\paragraph*{Issues}\subsubsection*{Adding Friends}\paragraph*{Implementation}\paragraph*{Issues}\subsubsection*{GPS Location}\paragraph*{Implementation}\paragraph*{Issues}\subsubsection*{Maps}\paragraph*{Implementation}\paragraph*{Issues}\subsubsection*{Posting message}\paragraph*{Implementation}\paragraph*{Issues}\subsubsection*{Retrieving messages}\paragraph*{Implementation}\paragraph*{Issues}\subsubsection*{Retrieving notifications}\paragraph*{Implementation}\paragraph*{Issues}\subsubsection*{Comments}\paragraph*{Implementation}\paragraph*{Issues}\subsubsection*{Votes}\paragraph*{Implementation}\paragraph*{Issues}\section{Server side application}This section covers the overall implementation and setup of the backend services required to get the application working, it will not talk about design this is covered in chapter \ref{ch:design} section \ref{sec:server_side_design}.\subsection{Environment}This section covers the environment the application will be run in with the server side. The development environments slightly from the technologies covered in this section, instead of a Linux based machine running the application the development system used is a Apple Mac, this should not create any issues as the technologies chosen are highly portable and work on many different operating systems.\subsubsection{Debian based Linux}\label{sec:debian_server}For running the server side services it was decided that a Linux based server would be the best as it offers the flexibility needed to run all the applications and services needed to get application working as intended. Due to prior knowledge of Debian based distributions it was decided to use a strictly Debian based server as the test server, and due to some stability issues for the production server to use Ubuntu Server 14.04.\\\\The justification of two servers comes down to trying to emulate the the structure that most company use of having a server for testing the application so that test data does not get put into a production environment and cause issues within the production environment. It is fairly fundamental that production users data is not mixed in with the development and test data as this could cause confusion and make it harder to see what is a test and what is actual user data. Segregating testing and production is also integral for testing as production users can be left on the stable platform in production till the version in test has been fully tested and proven to be stable where it can then be moved to the production server for the users to use.\\\\Both of the server installations used are provided by Digital Oceans which is the hosting service that was chosen to run the application this decision was covered in details in section \ref{sec:digial_oceans}. Each of the installations had only the bare essentials installed on them to get the application working this should help with stability and mean that we are not wasting space, the frameworks and applications chosen to be installed on the servers were PostgreSQL and Node.js theses are the two core components to the backend application for this project.\\\\Deployment of both of the servers was relatively painless there was very small issues with version mismatches with the PostgreSQL version used within the development environments but once this was fixed there was no issues with the deployment of the applications on theses systems.\subsubsection{PostgreSQL Database}PostgeSQL is fairly complicated to configure correctly, it required a fair amount of reading of the PostgreSQL documentation \cite{Postgres:APIDocumentation:2015:online} to ensure the application was configured correctly, this was teamed with some versions mismatches the version within the Debian repositories was a few versions older than the most current and did not have some of the more advanced features that were being used within the application, in particular the JSON manipulation tools. To fix theses issues it required compiling PostgreSQL from the source code to ensure we had the correct version on the server.\\\\For the encryption used within the application extra modules need to be installed within the PostgreSQL installation and registered this was fairly hard to find documentation on but it was found within a StackOverflow post \cite{se:howtoinstallpgcrypto:2011:online}. \subsubsection{Node.js environment}It was decided for Node.js to ensure that the systems were running the latest version of the software that it would be wise to download the latest stable version from the Node.js website \cite{nodeteam:node:2015:online} this is supplied in a source code, it would then be compiled on the systems to ensure that they had the most up to date version of the software. It was fairly easy to compile and configure Node.js without any issues this was likely due to having done it in the past, next attention was set to getting the application running on the server with Node.js running after cloning the backend code onto the server it was simple enough to run 'npm install' and it would automatically pull all of the external libraries needed from the cloud using the Node Package Manager(NPM), NPM helps with deployment of the application and is good for keeping track of the Node.js applications running showing any exceptions or stack traces if the application falls over with a log file to give the full picture if something happens.\\\\Overall working with Node.js is very straightforward and enjoyable it gives a lot of freedom and has a large variety of libraries and packages that can be used to improve the application and saves reinventing the wheel. The language JavaScript that Node.js is implemented in allows a lot of flexibility to how functionality is implemented this coupled with the large arrange of 3rd party libraries and code bases to implement the functionality required by the user, for a fairly young environment it is very mature and used by fairly large organisations like the British Broadcasting Corporation or Walt Disney gives confidence it is a very competent platform building applications.\subsubsection{Digital Ocean Droplets}\label{sec:digial_oceans}For hosting the application Digital Ocean was chosen to be the company that hosted the application as they gave \$100 worth of hosting free to students through the Github Education bundle but it could of quite easily been any other of the big hosting companies for example HostGator or Gandi. The service given by Digital Oceans has been exceptional, they have the ability to spin up a virtual private server(VPS) or as they call it a Droplet in a matter of minutes and even give the options to have Node.js and PostgreSQL installed at the time the Droplet is created which is a great time saver.\\\\The customers service has been very good with helping with issues, as explained in section \ref{sec:debian_server} there were some issues with the PostgreSQL installation on Debian due to out of date repositories there representative gave a quick and well explained answer on how to upgrade and install the newer version of PostgreSQL they also gave advice on how to resolve a memory issue caused by the projects middle tier application. Although the memory issue has not been resolved the allocation of more memory has made the issue happen less frequently and this issue should be resolved during further development. The ability to dynamically resize the requirements of the server is a great help when debugging various issues and can help quickly when an application is under heavy load and means the owner of the application can decide when they need to to upgrade the capacity of the application depending on the situation that is occurring with the application at that time.\subsection{Middle tier application}This section will cover the implementation of the various parts of the middle tier application.\subsubsection{Core functionality}The spike work for the development of the middle-tier got of to a bad start with the wrong choice of framework making development problematic, how this issue was resolved in detail can be found in section \ref{sec:node_choice_of_tech}.\\\\After initial spike work implementation of the core structure of the middle tier was fairly straight forward and there was no show stopper while implementing the system, there were a few minor issues during the development of the middle tier, mostly down to badly written API documentation that did not fully explain the constructs of the library that was being used.\\\\There has been a few issues with trying to setup tests correctly to make sure that the API authenticates correctly with the client it took a few attempts to find a library that was capable of storing cookies correctly and parsing them and re-injecting into the header of other requests to authenticate the user.\\\\As it stands some of the functionality of the backend is incomplete there is no error handling for when things go wrong and this will be implemented within further development of the application. Again it should be noted that the authentication within the application as it stands is not up to a standard that could be used within a production environment.\\% -- write more maybe?\subsubsection{RESTful Interface}Implementing the RESTful interface within the application was fairly straight forward due to how the application has been designed where various URL routes are loaded dynamically so that as the various sections of the application can be implemented when they are needed and do not require changes to the rest of the application to implement the new URL route for the new functionality.\\\\There is one issue with the HAPI.js API that causes issues with the implementation if for example the application is working with a POST request and it the status of the request is successful there is a HTTP status for successful so replying to the server "reply('success');" will cause a 302 error code which the client interpret as a error and the client will fall over.\\\\The standard HAPI.js postRoute and getRoute have been overwritten within the design so that they are always secured when they are used within the application, as they have been overwritten to ensure that the developer always uses protection on the routes within the application. The implementation of security within the application was a provided by a mixture of external libraries and custom code to interface with the database to ensure that the user is entitled to access the application, it has been fairly straight forward to amalgamate this code together to provide the functionality needed to authenticate the user although this could be considered a weak spot for the authentication of the application as it was not written by a security expert and may be prone to errors.\\\\One small oversight at the time of developing the was that JSON objects do not encapsulate other useful objects that are used within the same function thus in the current design the user will be returned a user\_id and then will have todo another rest call to get the user object for the user\_id it had received rather than having the user object encapsulated in the first request.\subsubsection{Database Connector}The use of Sequelize \cite{SaschaDepold:Sequelize:2015:online} to act as a connector between the HAPI.js application and the PostgreSQL database may have been a bad decision due to the memory allocation issues caused by it. It may also be adding extra complexity where it is not needed as it is a object relational mapping type of framework and in the implementation of the application it is not being utilised at all and the use of raw queries is used instead that is passed through the API to the SQL engine to execute. A framework that would be better suited to the job may be node-postgres as this is a much smaller API that interacts with the postgreSQL engine and does not have the extra layer of complexity of an Object Relational Mapper on top of it.\\\\Implementation with Sequelize was fairly straightforward though as it gave all the features required to work with the database within its bounds of the framework, it gave nicely formated JSON object containing the information from the query and theses could be directly sent to the client without any manipulation at-all which helped cut down the complexity of editing and formatting the data in-between the database and the client.\subsection{Database level}This gives a overview of the implementation of the database for the project.\subsubsection{Tables}Implementing the tables was fairly simple and straight forward for the most part as the original design stayed the same throughout although with a few very minor changes to add in functionality that was was not assessed at the beginning of the project. Changes were made when some minor issues with the constraints placed on a table were not correct making it impossible to insert the correct data into the database. Modifications to the structure are discussed more in-depth in chapter \ref{ch:design} section \ref{sec:database_strucutre}.\\\\Some changes were made later in the implementation of unique data was inserted along with the constraints to check that the wrong values were not inserted into the database, the referencing between different columns also caused some issues during development as in the early stages of development there was a need to clear the tables to ensure that bad data was removed and would not interfere with the new data being inserted, the issues arise when trying to truncate the tables to give a fresh dataset to work with, truncating the tables would lead to a constraint error that would prevent the data being deleted as it thought there may still be references left in the other table that depend on the other references, this issue was overcome by using delete rather than truncate "truncate table messages" would fail but "delete from messages where 1 = 1" would complete without error.\subsubsection{Functions}Functions within the database were a great time saver in the implementation of the application as functions could be written in the database to do checks to ensure that the data being inserted was correct, along with writing functions to validate that the authentication details are correct without pulling data out of the database and doing a context switch between the SQL engine and the Node.js application which will ultimately slow down the application dramatically if it has to do a lot of context switching.\\\\The implementation of the database function was fairly straight forward after the first one was implemented, there was some issues due to this being the first time using PostgreSQL but it was quickly sorted after a few functions had been implemented and difference between PostgreSQL and PL-SQL had clicked. PostgreSQL functions were one of the most interesting concepts that was used throughout the development of the application as it helped with speeding up the application and ensuring that the data inserted into the database was validated and manipulated correctly before being inserted into the database, the slight oddity with how functions is called took a while to get over to run a database function within the SQL engine you must issue a SELECT command for example "select function\_name('some','data');" which was a little unusual.\\\\Triggers in PostgreSQL are implemented very slightly differently than PL-SQL which took a while to understand but all the issues with the implementation of various features in PostgreSQL were easily answered by referring to the API documentation \cite{Postgres:APIDocumentation:2015:online} for the SQL engine.\section{Review of implementation}%-- TODO: